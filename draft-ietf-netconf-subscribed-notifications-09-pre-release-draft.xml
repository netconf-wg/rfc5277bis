<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-netconf-subscribed-notifications-09" ipr="trust200902">
  <front>
    <title abbrev="Subscribed Notifications">Custom Subscription to Event Streams</title>

    <author fullname="Eric Voit" initials="E." surname="Voit">
        <organization>Cisco Systems</organization>
        <address>
            <email>evoit@cisco.com</email>
        </address>
    </author>
    
    <author fullname="Alexander Clemm" initials="A" surname="Clemm">
        <organization>Huawei</organization>
        <address>
            <email>ludwig@clemm.org</email>
        </address>
    </author>
    
    <author fullname="Alberto Gonzalez Prieto" initials="A"
        surname="Gonzalez Prieto">
        <organization>VMWare</organization>
        <address>
            <email>agonzalezpri@vmware.com</email>
        </address>
    </author>

    <author fullname="Einar Nilsen-Nygaard" initials="E"
        surname="Nilsen-Nygaard">
        <organization>Cisco Systems</organization>
        <address>
            <email>einarnn@cisco.com</email>
        </address>
    </author>
      
    <author fullname="Ambika Prasad Tripathy" initials="A" surname="Tripathy">
        <organization>Cisco Systems</organization>
        <address>
            <email>ambtripa@cisco.com</email>
        </address>
    </author>

    <date day="24" month="January" year="2018"/>

    <area>Operations &amp; Management</area>

    <workgroup>NETCONF</workgroup>

    <keyword>Draft</keyword>

    <abstract>
        <t>This document defines capabilities and operations for the customized establishment of subscriptions upon a publisher's event streams.  Also defined are delivery mechanisms for instances of the resulting notification messages. Effectively this allows a subscriber to request and receive a continuous, custom feed of publisher generated information.</t>
    </abstract>
  </front>

  <middle>
      <section title="Introduction">
        
        <t>This document defines capabilities and operations for the customized establishment of subscriptions upon system generated event streams. Effectively this enables a "subscribe then publish" capability where the customized information needs of each target receiver are understood by the publisher before subscribed event records are marshaled and pushed. The receiver then gets a continuous, custom feed of publisher generated information.</t>
            
        <t>While the functionality defined in this document is transport-agnostic,  protocols like NETCONF <xref target="RFC6241"/> or RESTCONF <xref target="RFC8040"/> can be used to configure or dynamically signal subscriptions, and there are bindings defined for subscribed event record delivery for NETCONF within  <xref target="I-D.draft-ietf-netconf-netconf-event-notifications"/>, and for HTTP2 or HTTP1.1 within  <xref target="I-D.draft-ietf-netconf-restconf-notif"/>.</t>
        
        <section title="Motivation">  

          <t>There are various <xref target="RFC5277"/> limitations, many of which have been exposed in <xref target="RFC7923"/> which needed to be solved.  Key capabilities supported by this document include:</t>

          <t><list style="symbols">
            <t>multiple subscriptions on a single transport session</t>
            <t>support for dynamic and statically configured subscriptions</t>
            <t>modification of an existing subscription</t>
            <t>operational counters and instrumentation</t>
            <t>negotiation of subscription parameters (through the use of hints returned as part of declined subscription requests)</t>
            <t>state change notifications (e.g., publisher driven suspension, parameter modification)</t>
            <t>independence from transport protocol</t>
          </list></t>
        </section>

        <section title="Terminology">
          <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
          <t>Configured subscription: A subscription installed via a configuration interface which persists across reboots.</t>
          <t>Dynamic subscription: A subscription agreed between subscriber and publisher created via an establish-subscription RPC.</t>
          <t>Event: An occurrence of something that may be of interest. (e.g., a configuration change, a fault, a change in status, crossing a threshold, or an external input to the system.)</t>
          <t>Event record: A set of information detailing an event.</t>
          <t>NACM: NETCONF Access Control Model.</t>
          <t>Notification message: A set of transport encapsulated information intended for a receiver indicating that one or more event(s) have occurred.  A notification message may bundle multiple event records. This includes the bundling multiple, independent RFC 7950 YANG notifications.</t>
          <t>Publisher: An entity responsible for streaming notification messages per the terms of a Subscription.</t>
          <t>Receiver: A target to which a publisher pushes subscribed event records. For dynamic subscriptions, the receiver and subscriber are the same entity.</t>
          <t>Stream (also referred to as "event stream"):  A continuous ordered set of events aggregated under some context.</t>
          <t>Stream filter: Evaluation criteria which may be applied against event records within a stream. Event records pass the filter when specified criteria are met.</t>
          <t>Subscribed event records: Event records which have met the terms of the subscription.  This include terms (such as security checks) enforced by the publisher.</t>
          <t>Subscriber: An entity able to request and negotiate a contract for the generation and push of event records from a publisher.</t>
          <t>Subscription: A contract with a publisher, stipulating which information one or more receivers wish to have pushed from the publisher without the need for further solicitation.</t>
        </section>

        <section title="Solution Overview">
          <t>This document describes a transport agnostic mechanism for subscribing to and receiving content from a stream instantiated within a publisher.  This mechanism is through the use of a subscription.</t> 
          
          <t>Two types of subscriptions are supported:</t>
                
          <t><list style="numbers">
            <t>Dynamic subscriptions, where a subscriber initiates a subscription negotiation with a publisher via RPC.  If the publisher wants to serve this request, it accepts it, and then starts pushing notification messages. If the publisher does not wish to serve it as requested, then an error response is returned.  This response MAY include hints at subscription parameters which would have been accepted.</t>
                    
            <t>Configured subscriptions, which allow the management of subscriptions via a configuration interface so that a publisher can send notification messages to configured receiver(s).  Support for this capability is optional.</t>
          </list></t>
        
          <t>Additional characteristics differentiating configured from dynamic subscriptions include:</t>
          <t><list style="symbols">
            <t>The lifetime of a dynamic subscription is bounded by the transport session used to establish it.  For connection-oriented stateful transport like NETCONF, the loss of the transport session will result in the immediate termination of any associated dynamic subscriptions.  For connectionless or stateless transports like HTTP, a lack of receipt acknowledgment of a sequential set of notification messages and/or keep-alives can be used to trigger a termination of a dynamic subscription.  Contrast this to the lifetime of a configured subscription.  This lifetime is driven by relevant configuration being present within the publisher's running configuration. Being tied to configuration operations implies configured subscriptions can be configured to persist across reboots, and implies a configured subscription can persist even when its publisher is fully disconnected from any network.</t>
                    
            <t>Configured subscriptions can be modified by any configuration client with write permission on the configuration of the subscription.  Dynamic subscriptions can only be modified via an RPC request made by the original subscriber.</t>
          </list></t>
          <t>Note that there is no mixing-and-matching of dynamic and configured operations on a single subscriptions.  Specifically, a configured subscription cannot be modified or deleted using RPCs defined in this document.  Similarly, a subscription established via RPC cannot be modified through configuration operations.  Also note that transport specific transport drafts based on this specification MUST detail the life cycles of both dynamic and configured subscriptions.</t>

          <t>The publisher MAY decide to terminate a dynamic subscription at any time. Similarly, it MAY decide to temporarily suspend the sending of notification messages for any dynamic subscription, or for one or more receivers of a configured subscription. Such termination or suspension is driven by internal considerations of the publisher.</t>
        </section>
        
        <section title="Relationship to RFC-5277">    
          <t>This document is intended to provide a superset of the subscription capabilities initially defined within <xref target="RFC5277"/>.  Especially when extending an existing <xref target="RFC5277"/> implementation, it is important to understand what has been reused and what has been replaced. Key relationships between these two documents include:
          <list style="symbols">  
            <t>the data model in this document replaces the data model in <xref target="RFC5277"/>.</t> 
            <t>the RPC operations in this draft replaces the symmetrical operations of <xref target="RFC5277"/>, section 4.</t>
            <t>the one way operation of <xref target="RFC5277"/> is still used.  However this operation will no longer be required with the availability of <xref target="I.D.draft-ietf-netconf-notification-messages"/>. </t>
            <t>the definition and contents of the NETCONF stream are identical between this document and <xref target="RFC5277"/>.</t>
            <t>a publisher MAY implement both the data model and RPCs defined in <xref target="RFC5277"/> and this new document concurrently, in order to support old clients.  However the use of both alternatives on a single transport session is prohibited.</t>
          </list>
          </t>
        </section>
        
      </section>
      
      <section title="Solution">  
      
        <section title="Event Streams">
          <t>An event stream is a named entity on a publisher which exposes a continuously updating set of event records.  Each event stream is available for subscription. It is out of the scope of this document to identify a) how streams are defined, b) how event records are defined/generated, and c) how event records are assigned to streams.</t>
                
          <t>There is only one reserved event stream within this document: NETCONF.  The NETCONF event stream contains all NETCONF XML event record information supported by the publisher, except for where it has been explicitly indicated that this the event record MUST be excluded from the NETCONF stream.  The NETCONF stream will include individual YANG notifications as per <xref target="RFC7950"/> section 7.16.  Each of these YANG notifications will be treated a distinct event record. Beyond the NETCONF stream, implementations are free to add additional event streams.</t>
                
          <t>As event records are created by a system, they may be assigned to one or more streams.  The event record is distributed to subscription's receiver(s) where: (1) a subscription includes the identified stream, and (2) subscription filtering does not exclude the event record from that receiver.</t>

          <t>If access control permissions are in use to secure publisher content, then for event records to be sent to a receiver, that receiver MUST be allowed access to all the event records on the stream.  If subscriber permissions change during the lifecycle of a subscription, then the subscription MUST be continued or terminated accordingly.</t>
        </section>
            
        <section title="Event Stream Filters">            
          <t>This document defines an extensible filtering mechanism. Two optional stream filtering syntaxes supported are <xref target="XPATH"/> and subtree <xref target="RFC6241"/>. A filter always removes a complete event record; a subset of information is never stripped from an event record.</t>
          
          <t>If no stream filter is provided within a subscription, all event records on a stream are to be sent.</t>

        </section>
        
        <section title="QoS">            
          <t>This document provides an optional feature describing QoS parameters.  These parameters indicate the treatment of a subscription relative to other traffic between publisher and receiver.  Included are:
            <list style="symbols">
                <t>A "dscp" QoS marking to differentiate transport QoS behavior.  Where provided, this marking MUST be stamped on notification messages.</t>
                <t>A "weighting" so that bandwidth proportional to this weighting can be allocated to this subscription relative to other subscriptions destined for that receiver.</t>
                <t>a "dependency" upon another subscription. Notification messages MUST NOT be sent prior to other notification messages containing update record(s) for the referenced subscription.</t>
            </list>
            </t>
            <t>A subscription's weighting MUST work identically to stream dependency weighting as described within RFC 7540, section 5.3.2.</t>
            <t>A subscription's dependency MUST work identically to stream dependency as described within <xref target="RFC7540"/>, sections 5.3.1, 5.3.3, and 5.3.4.  If a dependency is attempted via an RPC, but the referenced subscription does not exist, the dependency will be silently removed.</t>

        </section>
      
        <section title="Dynamic Subscriptions" anchor="dynamic_subs">
          <t>Dynamic subscriptions are managed via RPC, and are made against targets located within the publisher.  These RPCs have been designed extensibly so that they may be augmented for subscription targets beyond event streams.</t>
          
          <section title="Dynamic Subscription State Model">
            <t>Below is the publisher's state machine for a dynamic subscription.  It is important to note that such a subscription doesn't exist at the publisher until it an "establish-subscription" RPC is accepted. The mere request by a subscriber to establish a subscription is insufficient for that asserted subscription to be externally visible.</t>

            <figure align="center" title="Dynamic subscription state">
              <artwork align="left"><![CDATA[ 
                    .-------.
                    | start |
                    '-------'
                        |
               establish-subscription
                        |
                        |   .------modify-subscription-------.
                        v   v                                '
                  .-----------.                         .-----------.
       .--------. | receiver  |-subscription-suspended->| receiver  |
     modify-     '|  active   |                         | suspended |
     subscription |           |<--subscription-resumed--|           |
       ---------->'-----------'                         '-----------'
                        |                                    |
             delete/kill-subscription                   delete/kill-
                        |                               subscription
                        v                                    |
                    .-------.                                |
                    |  end  |<-------------------------------'
                    '-------'
              ]]></artwork>
            </figure>

            <t>Of interest in this state machine are the following:
            <list style="symbols">
              <t>Successful establish or modify RPCs put the subscription into an active state.</t>

              <t>Failed modify RPCs will leave the subscription in its previous state, with no visible change to any streaming updates.</t>

              <t>A delete or kill RPC will end the subscription.</t>
           
              <t>Suspend and resume state changes are driven by internal process and prioritization.  There are no direct controls over suspend and resume other than modifying a subscription</t>
            </list></t>
          
          </section>
 
          <section title="Establishing a Subscription" anchor="sec_establish_subs">
            <t>The "establish-subscription" operation allows a subscriber to request the creation of a subscription via RPC. It MUST be possible to support multiple establish subscription RPC requests made within the same transport session.</t>  
            <t>The input parameters of the operation are:
            <list style="symbols">
              <t>A stream name which identifies the targeted stream of events against which the subscription is applied.</t>
              <t>A stream filter which may reduce the set of event records pushed.</t>
              <t>An optional encoding for the event records pushed.  Note: If no encoding is included, the encoding of the RPC MUST be used.</t>
              <t>An optional stop time for the subscription. If no stop-time is present, notification messages will continue to be sent until the subscription is terminated.</t>
              <t>An optional start time which indicates that this subscription is requesting a replay of previously generated information from the event stream.  For more on replay, see <xref target="replay_subs"/>.</t>  
            </list>
            </t>
            
            <t>If the publisher can satisfy the "establish-subscription" request, it provides an identifier for the subscription, and immediately starts streaming notification messages. </t>
                
            <figure align="center" title="establish-subscription RPC"
                anchor="establish-subscription-RPC">       
              <artwork align="left"><![CDATA[
    +---x establish-subscription
       +---w input
       |  +---w encoding?                encoding
       |  +---w (target)
       |  |  +--:(stream)
       |  |     +---w (stream-filter)?
       |  |     |  +--:(by-reference)
       |  |     |  |  +---w stream-filter-ref        stream-filter-ref
       |  |     |  +--:(within-subscription)
       |  |     |     +---w (filter-spec)?
       |  |     |        +--:(stream-subtree-filter)
       |  |     |        |  +---w stream-subtree-filter?    {subtree}?
       |  |     |        +--:(stream-xpath-filter)
       |  |     |           +---w stream-xpath-filter?     
       |  |     |                                 yang:xpath1.0 {xpath}?
       |  |     +---w stream?               stream-ref
       |  |     +---w replay-start-time?    yang:date-and-time {replay}?
       |  +---w stop-time?               yang:date-and-time
       |  +---w dscp?                    inet:dscp {qos}?
       |  +---w weighting?               uint8 {qos}?
       |  +---w dependency?              sn:subscription-id {qos}?
       +--ro output
          +--ro identifier                subscription-id      
              ]]></artwork>
            </figure>
            
            <t>A publisher MAY reject this RPC for many reasons as described in <xref target="appendix_a1"/>. The contents of the resulting RPC error response MAY include one or more hints on alternative inputs which would have resulted in a successfully established subscription.  Such hints MUST be transported within a yang-data "establish-subscription-error-stream" container included within the RPC error response.</t>
            
            <figure align="center" title="establish-subscription RPC yang-data"
                anchor="establish-subscription-RPC-yang-data">       
              <artwork align="left"><![CDATA[
    yang-data establish-subscription-error-stream
       +--ro establish-subscription-error-stream
          +--ro reason?                   identityref
          +--ro filter-failure-hint?      string
          +--ro replay-start-time-hint?   yang:date-and-time          
              ]]></artwork>
            </figure>
                
            <section title="Replay Subscription" anchor="replay_subs">
              <t>Replay provides the ability to establish a subscription which is also capable of passing recently generated event records.  In other words, as the subscription initializes itself, it sends any previously generated content from within target event stream which meets the filter and timeframe criteria.  These historical event records would then be followed by event records generated after the subscription has been established.  All event records will be delivered in the order generated.</t>

              <t>Replay is an optional feature which is dependent on an event stream supporting some form of logging. Replay puts no restrictions on the size or form of the log, or where it resides within the device.</t>

              <t>The inclusion of a replay-start-time within an "establish-subscription" RPC indicates a replay request. If the "replay-start-time" contains a value that is earlier than content stored within the publisher's replay buffer, then the subscription MUST be rejected, and the leaf "replay-start-time-hint" MUST be set in the reply.</t>

              <t>If a "stop-time" parameter is included, it MAY also be earlier than the current time and MUST be later than the "replay-start-time".  The publisher MUST NOT accept a "replay-start-time" for a future time.</t>
                    
              <t>If the "replay-start-time" is later than any information stored in the replay buffer, then the publisher MUST send a "replay-completed" notification immediately after the "subscription-started" notification.</t>

              <t>If a stream supports replay, the "replay-support" leaf is present in the "/streams/stream" list entry for the stream. An event stream that does support replay is not expected to have an unlimited supply of saved notifications available to accommodate any given replay request. To assess the availability of replay, subscribers can perform a get on "replay-log-creation-time" and "replay-log-aged-time". See <xref target="stream-tree"/> for the tree describing these elements.  The actual size of the replay log at any given time is a publisher specific matter. Control parameters for the replay log are outside the scope of this document.</t>
            </section>
          </section>                     
            
          <section title="Modifying a Subscription">
            <t>The "modify-subscription" operation permits changing the terms of an existing dynamic subscription previously established on that transport session via "establish-subscription".  Dynamic subscriptions can be modified one or multiple times. If the publisher accepts the requested modifications, it replies with "ok", then immediately starts sending event records based on the new terms.</t> 
            
            <t>Dynamic subscriptions established via RPC can only be modified via RPC using the same transport session used to establish that subscription. Subscriptions created by configuration operations cannot be modified via this RPC.</t>
                
            <figure align="center" title="modify-subscription RPC"
                anchor="modify-subscription-RPC">         
              <artwork align="left"><![CDATA[
    +---x modify-subscription
       +---w input
       |  +---w identifier?              subscription-id
       |  +---w (target)
       |  |  +--:(stream)
       |  |     +---w (stream-filter)?
       |  |        +--:(by-reference)
       |  |        |  +---w stream-filter-ref        stream-filter-ref
       |  |        +--:(within-subscription)
       |  |           +---w (filter-spec)?
       |  |              +--:(stream-subtree-filter)
       |  |              |  +---w stream-subtree-filter?    {subtree}?
       |  |              +--:(stream-xpath-filter)
       |  |                 +---w stream-xpath-filter?     
       |  |                                       yang:xpath1.0 {xpath}?
       |  +---w stop-time?               yang:date-and-time
       +--ro output
          +--ro ok    empty
              ]]></artwork>
            </figure>
            
            <t>If the publisher accepts the requested modifications on a currently suspended subscription, the subscription will immediately be resumed (i.e., the modified subscription is returned to an active status.)  The publisher MAY immediately suspend this newly modified subscription through the "subscription-suspended" notification before any event records are sent.</t>
            
            <t>If the publisher rejects the RPC request, the subscription remains as prior to the request. That is, the request has no impact whatsoever.  Rejection of the RPC for any reason is indicated by via RPC error as described in <xref target="appendix_a1"/>. The contents of a such a rejected RPC MAY include one or more hints on alternative inputs which would have resulted in a successfully modified subscription.  These hints MUST be transported within a yang-data "modify-subscription-error-stream" container inserted into the RPC error response.</t>
            
            <figure align="center" title="modify-subscription RPC yang-data"
                anchor="modify-subscription-RPC-yang-data">         
              <artwork align="left"><![CDATA[      
    yang-data modify-subscription-error-stream
       +--ro modify-subscription-error-stream
          +--ro reason?                identityref
          +--ro filter-failure-hint?   string
              ]]></artwork>
            </figure>
                
          </section>
            
          <section title="Deleting a Subscription">
            <t>The "delete-subscription" operation permits canceling an existing subscription previously established on that transport session. If the publisher accepts the request, and the publisher has indicated this success via an "ok", the publisher MUST NOT send any more notification messages for this subscription. If the publisher rejects the request, the request has no impact whatsoever on any subscription.</t>
                
            <figure align="center" title="delete-subscription RPC"
                anchor="delete-subscription-RPC">         
              <artwork align="left"><![CDATA[
    +---x delete-subscription
       +---w input
       |  +---w identifier    subscription-id
       +--ro output
          +--ro ok    empty      
              ]]></artwork>
            </figure>
            
            <t>Dynamic subscriptions can only be deleted via this RPC using the same transport session previously used for subscription establishment. Configured subscriptions cannot be deleted using RPCs.</t>
                
          </section>
            
          <section title="Killing a Subscription">
            <t>The "kill-subscription" operation permits an operator to end a dynamic subscription which is not associated with the transport session used for the RPC.  This operation MUST be secured so that only connections with sufficiently privileged access rights are able to invoke this RPC.  A publisher MUST terminate any dynamic subscription identified by RPC request.  An operator may find subscription identifiers which may be used with "kill-subscription" by searching for the IP address of a receiver within "subscriptions\subscription\receivers\receiver\address".</t>
            
            <t>Configured subscriptions cannot be killed using this RPC.  Instead, configured subscriptions are deleted as part of regular configuration operations. Publishers MUST reject any RPC attempt to kill a configured subscription.</t>
                
            <t>The tree structure of "kill-subscription" is almost identical to "delete-subscription", with only the name of the RPC and yang-data changing.</t>
          </section>
            
        </section>
     
        <section title="Configured Subscriptions">
          <t>A configured subscription is a subscription installed via a configuration interface. Configured subscriptions may be modified by any configuration client with the proper permissions. Subscriptions can be modified or terminated via the configuration interface at any point of their lifetime.</t>
        
          <t>Configured subscriptions have several characteristics distinguishing them from dynamic subscriptions:
          <list style="symbols">
            <t>persistence across reboots,</t>
            <t>persistence even when transport is unavailable, and</t>
            <t>an ability to send notification messages to more than one receiver (note that the publisher does not provide information to a receiver about other receivers.)</t>
          </list>
          </t>
        
          <t>Supporting configured subscriptions is optional and advertised using the "configured" feature. </t>
                            
          <t>In addition to subscription parameters available to dynamic subscriptions as described in <xref target="sec_establish_subs"/>, the following additional parameters are also available to configured subscriptions: 
          <list style="symbols">
            <t>One or more receiver IP addresses (and corresponding ports) intended as the destination for notification messages.</t>

            <t>Optional parameters to identify an egress interface, a host IP address, a VRF (as defined by the network instance name within <xref target="I-D.draft-ietf-rtgwg-ni-model"/>), or an IP address plus VRF out of which notification messages are to be pushed from the publisher.  Where any of this info is not explicitly included, or where just the VRF is provided, notification messages MUST egress the publisher's default interface towards that receiver.</t>
          </list>
          </t>
        
          <section title="Configured Subscription State Model">
            <t>Below is the state machine for a configured subscription. The creation or modification of a configured subscription initiates a publisher evaluation to determine if the subscription is valid or invalid.  The publisher uses its own criteria in making this determination.  If valid, the subscription becomes operational. </t>
            
            
            <figure align="center" 
                title="Configured subscription status.">
              <artwork align="left"><![CDATA[ 
.-------.
| start |-.   
'-------' | 
     create  .---modify-----.----------------------------------.
          |  |              |                                  |         
          V  V          .-------.         .-----.         .---------.      
 .----[evaluate]--no--->|invalid|-delete->| end |<-delete-|concluded| 
 |                      '-------'         '-----'         '---------'
 |----[evaluate]--no-.      ^                ^                 ^  
 |        ^          |      |                |                 |        
yes       |          '->unsupportable      delete           stop-time     
 |      modify         (subscription-   (subscription-   (subscription- 
 |        |              terminated)      terminated)      concluded)      
 |        |                 |                |                 |        
 |   .---------------------------------------------------------------.
 '-->|                         valid                                 |
     '---------------------------------------------------------------'
               ]]></artwork>
            </figure>                     
            
            <t>A valid subscription may become invalid on one of two ways.  First, it may be modified in a way which fails a re-evaluation. Second, the publisher itself might itself determine that the subscription in no longer supportable.  In either case, a "subscription-terminated" notification is sent to any active or suspended receivers.  A valid subscription may also transition to a concluded status if a configured stop time has been reached.  In this case, a "subscription-concluded" is sent to any active or suspended receivers.</t>
            
            <t>During any times a subscription is considered valid, a publisher will attempt to connect with all configured receivers and deliver notification messages.  Below is the state machine for each receiver of a configured subscription. This receiver state machine itself is fully contained within the state machine of the configured subscription, and is only relevant when the configured subscription itself is determined to be valid.</t>
        
            <figure align="center" 
                title="Configured receiver state">
              <artwork align="left"><![CDATA[ 
     .----------------------------------------------------------------.
     |                         valid                                  |
     |   .----------.                           .--------.            |
     |   | receiver |------------------timeout->|receiver|            |
     |   |connecting|<------------------reset---|timeout |            |
     |   |          |<-transport---.            '--------'            |
     |   '----------'  loss,reset  |                                  |
     |       |           |         |                                  |
     | (subscription     |         |                                  |
     |  started)    .--------.     |                      .---------. |
     |       '----->|        |     '----------------------|         | | 
     |              |receiver|-(subscription-suspended)-->|receiver | |
     |(subscription-| active |                            |suspended| |
     |   modified)  |        |<-(subscription-resumed,----|         | |
     |        '---->'--------'   subscription-modified)   '---------' |
     '----------------------------------------------------------------'  
               ]]></artwork>
            </figure> 

            <t>When a subscription first becomes valid, the operational status of each receiver is initialized to connecting. Individual are receivers are moved to an active status when a "subscription-started" state change notification is successfully passed to that receiver. Configured  receivers remain active if transport connectivity is not lost, and event records are not being dropped due to a publisher buffer overflow.  A configured subscription's receiver MUST be moved to connecting if transport connectivity is lost, or if the receiver is reset via configuration operations.</t>

            <t>A configured subscription's receiver MUST be moved to a suspended state if there is transport connectivity between the publisher and receiver, but notification messages are not being generated for that receiver.  A configured subscription receiver MUST be returned to an active state from the suspended state when notification messages are again being generated and a receiver has successfully been sent a "subscription-resumed" or a "subscription-modified".</t>

            <t>Modification of a configured subscription is possible at any time.  A "subscription-modified" state change notification will be sent to all active receivers, immediately followed by notification messages conforming to the new parameters.  Suspended receivers will also be informed of the modification.  However this notification will await the end of the suspension for that receiver.</t>       
        
            <t>The mechanisms described above is mirrored in the RPCs and YANG notifications within the document.  It should be noted that these RPCs and YANG notifications have been designed to be extensible and allow subscriptions into targets other than event streams.  <xref target="I-D.ietf-netconf-yang-push"/> provides an example of such an extension.</t>
          </section>

              
          <section title="Creating a Configured Subscription" anchor="sec_create_config_subs">
            <t>Configured subscriptions are established using configuration operations against the top-level subtree "subscription-config". There are two key differences between the new RPCs defined in this document and configuration operations for subscription creation. Firstly, configuration operations install a subscription without question, while the RPCs are designed to the support negotiation and rejection of requests. Secondly, while the RPCs mandate that the subscriber establishing the subscription is the only receiver of the notification messages, configuration operations permit specifying receivers independent of any tracked subscriber.  Because there is no explicit association with an existing transport session, configuration operations require additional parameters beyond those of dynamic subscriptions to indicate receivers, and possibly whether the notification messages need to come from a specific egress interface on the publisher.</t>
            
            <t>After a subscription is successfully created, the publisher immediately sends a "subscription-started" state change notification to each receiver.  It is quite possible that upon configuration, reboot, or even steady-state operations, a transport session may not be currently available to the receiver.  In this case, when there is something to transport for an active subscription, transport specific call-home operations will be used to establish the connection.  When transport connectivity is available, notification messages may then be pushed.</t>
            
            <t>With active configured subscriptions, it is allowable to buffer event records even after a "subscription-started" has been sent.  However if events are lost (rather than just delayed) due to replay buffer overflow, a new "subscription-started" must be sent.  This new "subscription-started" indicates an event record discontinuity.</t>
     
            <t>To see an example at subscription creation using configuration operations over NETCONF, see Appendix A of <xref target="I-D.draft-ietf-netconf-netconf-event-notifications"/>.</t>
                    
            <t>Note that is possible to configure replay on a configured subscription.  This capability is to allow a configured subscription to exist on a system so that event records generated during boot can be buffered and pushed as soon as the transport session is established.</t>
          </section>
                
          <section title="Modifying a Configured Subscription">
            <t>Configured subscriptions can be modified using configuration operations against the top-level subtree "subscription-config".</t>
            
            <t>If the modification involves adding receivers, added receivers are placed in the "connecting" state.  If a receiver is removed, the state change notification "subscription-terminated" is sent to that receiver if that receiver is "active" or "suspended" .</t>
            
            <t>If the modification involved changing the policies for the subscription, the publisher sends to currently active receivers a "subscription-modified" notification.  For any suspended receivers, a "subscription-modified" notification will be delayed until the receiver is resumed.  (Note: in this case, the "subscription-modified" notification informs the receiver that the subscription has been resumed, so no additional "subscription-resumed" need be sent.)</t>   
          </section>
                    
          <section title="Deleting a Configured Subscription">
            <t>Subscriptions can be deleted using configuration operations against the top-level subtree "subscription-config".</t>

            <t>Immediately after a subscription is successfully deleted, the publisher sends to all receivers of that subscription a state change notification stating the subscription has ended (i.e., "subscription-terminated").</t>                    
          </section>
          
          <section title="Resetting a Configured Receiver">
             <t>It is possible that a configured subscription to a receiver needs to be reset. This re-initialization may be useful in cases where a publisher has timed out trying to reach a receiver. When such a reset occurs, a transport session will be initiated if necessary, and a new "subscription-started" notification will be sent.</t>
          </section>
          
        </section>
    
        <section title="Event Record Delivery">
          <t>Whether dynamic or configured, once a subscription has been set up, the publisher streams event records via notification messages per the terms of the subscription. For dynamic subscriptions set up via RPC operations, notification messages are sent over the session used to establish the subscription.  For configured subscriptions, notification messages are sent over the connections specified by the transport, plus receiver IP address and port configured.</t>
        
          <t>A notification message is sent to a receiver when an event record is able to traverse the  specified filter criteria.  This notification message MUST be encoded as one-way notification element of <xref target="RFC5277"/>, Section 4.  The following example within <xref target="RFC7950"/> section 7.16.3 is an example of a compliant message:</t>
               
          <figure align="center" anchor="simple-data-plane-notif" title="subscribed notification message">       
            <artwork align="left"><![CDATA[
   <notification
          xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
       <eventTime>2007-09-01T10:00:00Z</eventTime>
       <link-failure xmlns="http://acme.example.com/system">
           <if-name>so-1/2/3.0</if-name>
           <if-admin-status>up</if-admin-status>
           <if-oper-status>down</if-oper-status>
       </link-failure>
   </notification>
            ]]></artwork>
          </figure>
                
          <t>This [RFC5277] section 4 one-way operation has the drawback of not including useful header information such as a subscription identifier. When using this mechanism, it is left up to implementations or augmentations to this document to determine which event records belong to which subscription.</t>
        
          <t>These drawbacks, along with other useful common headers and the ability to bundle multiple event records together is being explored within <xref target="I.D.draft-ietf-netconf-notification-messages"/>.  When the notification-messages is supported, this document will be updated to indicate support.</t>

        </section>
        
        <section title="Subscription State Notifications"  anchor="state_notif">
          <t>In addition to subscribed event records, a publisher will send subscription state notifications to indicate to receivers that an event related to the subscription management has occurred.</t>
          
          <t>Subscription state notifications are unlike other notifications which might be found in the event stream.  They cannot be filtered out, and they are delivered only to directly impacted receiver(s) of a subscription.  The identification of subscription state notifications is easy to separate from other notification messages through the use of the YANG extension "subscription-state-notif".  This extension tags a notification as subscription state notification. </t>
          
          <t>The complete set of subscription state notifications is described in the following subsections.</t>
                
          <section title="subscription-started">
            <t>This notification indicates that a configured subscription has started, and event records may be sent. Included in this state change notification are all the parameters of the subscription, except for the receiver(s) addressing information and origin information indicating where notification messages will egress the publisher.  Note that if a referenced filter from the "filters" container has been used within the subscription, the notification will include the contents of that referenced under the "within-subscription" subtree.</t>
            
            <t>Note that for dynamic subscriptions, no "subscription-started" notifications are ever sent.</t>
            
            <figure align="center" title="subscription-started notification"
                anchor="subscription-started-notification">       
              <artwork align="left"><![CDATA[
+---n subscription-started {configured}?
   +--ro identifier               subscription-id
   +--ro protocol                 transport {configured}?
   +--ro encoding                 encoding
   +--ro (target)
   |  +--:(stream)
   |     +--ro (stream-filter)?
   |     |  +--:(by-reference)
   |     |  |  +--ro stream-filter-ref        stream-filter-ref
   |     |  +--:(within-subscription)
   |     |     +--ro (filter-spec)?
   |     |        +--:(stream-subtree-filter)
   |     |        |  +--ro stream-subtree-filter?    {subtree}?
   |     |        +--:(stream-xpath-filter)
   |     |           +--ro stream-xpath-filter?   yang:xpath1.0 {xpath}?
   |     +--ro stream                   stream
   |     +--ro replay-start-time?       yang:date-and-time {replay}?
   +--ro stop-time?               yang:date-and-time
   +--ro dscp?                    inet:dscp {qos}?
   +--ro weighting?               uint8 {qos}?
   +--ro dependency?              sn:subscription-id {qos}?
              ]]></artwork>
            </figure>
            
          </section>
                
          <section title="subscription-modified">
            <t>This notification indicates that a subscription has been modified by configuration operations. The same parameters of "subscription-started" are provided via this notification.  As a result, the tree structure of "subscription-modified" is almost identical to "subscription-started", with only the name of the notification changing.</t>
            
            <t>A publisher most often sends this notification directly after the modification of any configuration parameters impacting a configured subscription.  But it may also be sent at two other times.  
            
            <list style="symbols">
            <t>First, where a configured subscription has been modified during the suspension of a receiver, the notification will be delayed until the receiver's suspension is lifted.  In this situation, the notification indicates that the subscription has been both modified and resumed.</t> 

            <t>Second, for dynamic subscriptions, there is one and only one time this notification may be sent. A "subscription-modified" state change notifications MUST be sent if the contents of a filter identified by a "stream-filter-ref" has changed.</t>
            
            </list></t>            
          </section>
                
          <section title="subscription-terminated">
            <t>This notification indicates that a subscription has been terminated on the publisher. The state change notification includes the reason for the termination. Viable reasons are described in <xref target="appendix_a2"/>.</t> 
            
            <t>The publisher MAY decide to terminate a subscription rather than continuing to serve it.  Such a decision may be made when a publisher runs out of resources, an internal error occurs, or some other reason. Publisher-driven terminations are always notified to all receivers.</t>
          
            <t>Subscribers themselves can terminate existing subscriptions established via a "delete-subscription" RPC. In such cases, no "subscription-terminated" state change notifications are sent.  However if a "kill-subscription" RPC is sent, or some other event other than reaching the subscription's stop time results in the end of a subscription, then this state change notification MUST be sent. </t>
            
            <figure align="center" title="subscription-terminated notification"
                anchor="subscription-terminated-notification">         
              <artwork align="left"><![CDATA[
    +---n subscription-terminated
       +--ro identifier        subscription-id
       +--ro error-id          subscription-errors
       +--ro filter-failure?   string
              ]]></artwork>
            </figure>
          </section>
                
          <section title="subscription-suspended">
            <t>This notification indicates that a publisher has suspended the sending of event records to a receiver, and also indicates the possible loss of events. The state change notification includes the reason for the suspension as described in <xref target="appendix_a2"/>. No further notification will be sent until the subscription resumes or is terminated. </t>
          
            <t>The tree structure of "subscription-suspended" is almost identical to "subscription-terminated", with only the name of the notification changing.</t>
          </section>
                
          <section title="subscription-resumed">
            <t>This indicates that a previously suspended subscription has been resumed under the unmodified terms previously in place. Subscribed event records generated after the generation of this state change notification will be sent.</t>
          
            <figure align="center" title="subscription-resumed notification"
                anchor="subscription-resumed-notification">         
              <artwork align="left"><![CDATA[
    +---n subscription-resumed
       +--ro identifier    subscription-id
            ]]></artwork>
            </figure>
          </section>
        
          <section title="subscription-completed">
            <t>This notification indicates that a subscription, which includes a "stop-time", has successfully finished passing event records upon the reaching of that time.</t>
          
            <t>The tree structure of "subscription-completed" is almost identical to "subscription-resumed", with only the name of the notification changing.</t>
          </section>
        
          <section title="replay-completed">
            <t>This notification indicates that all of the event records prior to the current time have been sent.  This includes new event records generated since the start of the subscription. This notification MUST NOT be sent for any other reason. </t>
            
            <t>If subscription contains no "stop-time", or has a "stop-time" which has not been reached, then after the "replay-completed" notification has been sent, additional event records will be sent in sequence as they arise naturally on the publisher.</t>
            
            <t>The tree structure of "replay-completed" is almost identical to "subscription-resumed", with only the name of the notification changing.</t>
          </section>
               
        </section>
        
        <section title="Subscription Monitoring">
          <t>Container "subscriptions" in the YANG module contains the state of all known subscriptions. This includes subscriptions that were established (and have not yet been deleted) using RPCs, as well as subscriptions that have been configured as part of configuration. Using the "get" operation with NETCONF, or subscribing to this information via <xref target="I-D.ietf-netconf-yang-push"/> allows the status of subscriptions to be monitored.</t>

          <t>Each subscription is represented as a list element. The associated information includes an identifier for the subscription, receiver counter information, the status of the subscription, as well as the various subscription parameters that are in effect. The subscription status indicates the subscription's state with each receiver (e.g., is currently active or suspended). Leaf "configured-subscription" indicates whether the subscription came into being via configuration or via RPC.</t>

          <t>Subscriptions that were established by RPC are removed from the list once they expire (reaching stop-time) or when they are terminated. Subscriptions that were established by configuration need to be deleted from the configuration by a configuration editing operation even if the stop time has been passed.</t>
        </section>

        <section title="Advertisement">
          <t>Publishers supporting this document MUST indicate support the YANG model "ietf-subscribed-notifications" within the YANG library of the publisher. In addition support for optional features: "encode-xml", "encode-json", "configured" "supports-vrf", and "replay" MUST also be indicated if supported.</t>
            
          <t>If a publisher supports this specification but not subscriptions via <xref target="RFC5277"/>, the publisher MUST NOT advertise "urn:ietf:params:netconf:capability:notification:1.0".  Even without this advertisement however, the publisher MUST support the one-way notification element of <xref target="RFC5277"/> Section 4.</t>       
        </section>
        
      </section>
        
      <section title="YANG Data Model Trees">  

        <t>This section contains tree diagrams for top level YANG Data Node containers defined in <xref target="data_model"/>.  If you would rather see tree diagrams for Notifications, see <xref target="state_notif"/>.  Or for the tree diagrams for the RPCs, see <xref target="dynamic_subs"/>.</t>
        
        <section title="Event Streams Container">
          
          <t>A publisher maintains a list of available event streams as operational data.  This list contains both standardized and vendor-specific event streams.  The list of event streams that are supported by the publisher and against which subscription is allowed may be acquired from the "streams" container within the YANG module.</t>
          
          <figure align="center" anchor="stream-tree"
                title="Stream Container">
            <artwork align="left"><![CDATA[           
 +--rw streams
    +--rw stream* [name]
       +--rw name                        stream
       +--rw description                 string
       +--rw replay-support?             empty {replay}?
       +--rw replay-log-creation-time?   yang:date-and-time {replay}?
       +--rw replay-log-aged-time?       yang:date-and-time {replay}?
            ]]></artwork>
          </figure>          
        </section>
            
        <section title="Event Stream Filters Container">            
          <t>The "filters" container maintains a list of all subscription filters which persist outside the life-cycle of a single subscription.  This enables pre-defined and validated filters which may be referenced and used by more than one subscription.</t>
          
          <figure align="center" anchor="filter-tree"
                title="Filter Container">
            <artwork align="left"><![CDATA[           
    +--rw filters
       +--rw stream-filter* [identifier]
          +--rw identifier               filter-id
          +--rw (filter-spec)?
             +--:(stream-subtree-filter)
             |  +--rw stream-subtree-filter?    {subtree}?
             +--:(stream-xpath-filter)
                +--rw stream-xpath-filter?     yang:xpath1.0 {xpath}?
            ]]></artwork>
          </figure>    
        </section>
           
            
        <section title="Subscriptions Container">

          <t>The "subscriptions" container maintains a list of all subscriptions on a publisher, both configured and dynamic.  It can be used to retrieve information about the subscriptions which a publisher is serving.</t>
    
          <figure align="left">
            <artwork align="left" xml:space="preserve"><![CDATA[   

+--ro subscriptions
   +--ro subscription* [identifier]
      +--ro identifier                       subscription-id
      +--ro configured-subscription-state?   enumeration {configured}?
      +--ro purpose?                         string {configured}?
      +--ro protocol                         transport {configured}?
      +--ro encoding                         encoding
      +--ro (target)
      |  +--:(stream)
      |     +--ro (stream-filter)?
      |     |  +--:(by-reference)
      |     |  |  +--ro stream-filter-ref          stream-filter-ref
      |     |  +--:(within-subscription)
      |     |     +--ro (filter-spec)?
      |     |        +--:(stream-subtree-filter)
      |     |        |  +--ro stream-subtree-filter?      {subtree}?
      |     |        +--:(stream-xpath-filter)
      |     |           +--ro stream-xpath-filter?
      |     |                                yang:xpath1.0 {xpath}?
      |     +--ro stream?                    stream-ref
      |     +--ro replay-start-time?    yang:date-and-time {replay}?
      +--ro stop-time?                     yang:date-and-time
      +--ro dscp?                          inet:dscp {qos}?
      +--ro weighting?                     uint8 {qos}?
      +--ro dependency?                    sn:subscription-id {qos}?
      +--ro (notification-message-origin)?
      |  +--:(interface-originated)
      |  |  +--ro source-interface?                if:interface-ref
      |  +--:(address-originated)
      |     +--ro source-vrf?                      -> 
      |  /ni:network-instances/network-instance/name {supports-vrf}?
      |     +--ro source-address?            inet:ip-address-no-zone
      +--ro receivers
         +--ro receiver* [address port]
            +--ro address                   inet:host
            +--ro port                      inet:port-number
            +--ro pushed-notifications?     yang:counter64
            +--ro excluded-notifications?   yang:counter64
            +--ro status                    enumeration
            +---x reset
               +--ro output
                  +--ro time    yang:date-and-time
            ]]></artwork>
          </figure>  

        </section>
    
        <section title="Subscription-config Container">
         
          <t>"Subscription-config" container contains the configuration of configured subscriptions.</t>

          <figure align="left">
            <artwork align="left" xml:space="preserve"><![CDATA[               
+--rw subscription-config {configured}?
  +--rw subscription* [identifier]
     +--rw identifier               subscription-id
     +--rw purpose?                 string
     +--rw protocol                 transport {configured}?
     +--rw encoding                 encoding
     +--rw (target)
     |  +--:(stream)
     |     +--rw (stream-filter)?
     |     |  +--:(by-reference)
     |     |  |  +--rw stream-filter-ref        stream-filter-ref
     |     |  +--:(within-subscription)
     |     |     +--rw (filter-spec)?
     |     |        +--:(stream-subtree-filter)
     |     |        |  +--rw stream-subtree-filter?    {subtree}?
     |     |        +--:(stream-xpath-filter)
     |     |           +--rw stream-xpath-filter? yang:xpath1.0 {xpath}?
     |     +--rw stream?                  stream-filter-ref
     |     +--rw replay-start-time?       yang:date-and-time {replay}?
     +--rw stop-time?               yang:date-and-time
     +--rw dscp?                    inet:dscp {qos}?
     +--rw weighting?               uint8 {qos}?
     +--rw dependency?              sn:subscription-id {qos}?
     +--rw (notification-message-origin)?
     |  +--:(interface-originated)
     |  |  +--rw source-interface?        if:interface-ref
     |  +--:(address-originated)
     |     +--rw source-vrf?              -> 
     |     | /ni:network-instances/network-instance/name {supports-vrf}?
     |     +--rw source-address?          inet:ip-address-no-zone
     +--rw receivers
        +--rw receiver* [address port]
           +--rw address    inet:host
           +--rw port       inet:port-number
            ]]></artwork>
          </figure>           
     
        </section>
    
      </section>

    
      <section title="Data Model" anchor="data_model">
        <figure>
          <artwork align="left"><![CDATA[
<CODE BEGINS> file "ietf-subscribed-notifications.yang"
module ietf-subscribed-notifications {
  yang-version 1.1;
  namespace 
    "urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications";

  prefix sn;

  import ietf-yang-types {
    prefix yang;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import ietf-interfaces {
    prefix if;
  }
  import ietf-network-instance {
    prefix ni;
  }
  import ietf-restconf   { 
    prefix rc;   
  }
  
  organization "IETF";
  contact
    "WG Web:   <http:/tools.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>
     
     Editor:   Alexander Clemm
               <mailto:ludwig@clemm.org>

     Editor:   Eric Voit
               <mailto:evoit@cisco.com>
               
     Editor:   Alberto Gonzalez Prieto
               <mailto:agonzalezpri@vmware.com>

     Editor:   Einar Nilsen-Nygaard
               <mailto:einarnn@cisco.com>

     Editor:   Ambika Prasad Tripathy
               <mailto:ambtripa@cisco.com>";

  description
    "Contains a YANG specification for subscribing to event records 
    and receiving matching content within notification messages.";
  
  revision 2018-01-24 {
    description
      "Initial version";
    reference 
      "draft-ietf-netconf-subscribed-notifications-09";
  }
  
  /*
   * FEATURES
   */
  
  feature encode-json {
    description
      "This feature indicates that JSON encoding of notification
       messages is supported.";
  }
  
  feature encode-xml {
    description
      "This feature indicates that XML encoding of notification
       messages is supported.";
  }

  feature configured {
    description
      "This feature indicates that configuration of subscription is
      supported.";
  }
  
  feature replay {
    description
      "This feature indicates that historical event record replay is 
      supported.  With replay, it is possible for past event records to 
      be streamed in chronological order.";
  }

  feature xpath {
    description
      "This feature indicates support for xpath filtering.";
    reference "http://www.w3.org/TR/1999/REC-xpath-19991116";
  }

  feature subtree {
    description
      "This feature indicates support for YANG subtree filtering.";
    reference "RFC 6241, Section 6.";
  }
  
  feature supports-vrf {
    description
      "This feature indicates a publisher supports VRF configuration
      for configured subscriptions.  VRF support for dynamic 
      subscriptions does not require this feature.";
    reference "draft-ietf-rtgwg-ni-model";
  }
  
  feature qos {
    description
      "This feature indicates a publisher supports one or more optional
      Quality of Service (QoS) features to differentiate update record
      treatment between publisher and receiver.";
  }
  
  /* 
   * EXTENSIONS
   */
   
  extension subscription-state-notification {
    description
      "This statement applies only to notifications. It indicates that 
       the notification is a subscription state notification. Therefore 
       it does not participate in a regular event stream and does not 
       need to be specifically subscribed to in order to be received.
       This statement can only occur as a substatement to the YANG
       'notification' statement."; 
  }
  
  /*
   * IDENTITIES
   */
  
  /* Identity for subscription success */
  identity ok {
    description
      "OK - RPC was successful and was performed as requested.";
  }

  /* Identities for RPC and Notification errors */ 
  
  identity establish-subscription-error {
     description
      "Problem found while attempting to fulfill an 
      'establish-subscription' rpc request. "; 
  }
  
  identity modify-subscription-error {
     description
      "Problem found while attempting to fulfill a
      'modify-subscription' rpc request. "; 
  }
  
  identity delete-subscription-error {
     description
      "Problem found while attempting to fulfill either a 
      'delete-subscription' rpc request or a 'kill-subscription'
      rpc request. "; 
  }
  
  identity subscription-terminated-reason {
     description
      "Problem condition communicated to a receiver as part of absolute 
      'subscription-terminated' notification. "; 
  }
  
  identity subscription-suspended-reason {
     description
      "Problem condition communicated to a receiver as part of absolute 
      'subscription-terminated' notification. "; 
  }
  
  identity dscp-unavailable {
    base establish-subscription-error;
    description 
      "Requested DSCP marking not allocatable.";
  }

  identity filter-unavailable {
    base subscription-terminated-reason;
    description
     "Referenced filter does not exist.  This means a receiver is
     referencing a filter which doesn't exist, or to which they do not
     have access permissions.";
  }
  
  identity filter-unsupported {
    base establish-subscription-error;
    base modify-subscription-error;
    description
     "Cannot parse syntax within the filter.  This failure can be from 
     a syntax error, or a syntax too complex to be processed by the 
     publisher.";
  }

  identity history-unavailable {
    base establish-subscription-error;
    description
     "Replay request too far into the past. This means the publisher
      does store historic information for the requested stream, but
      not back to the requested timestamp.";
  }

  identity insufficient-resources {
    base establish-subscription-error;
    base modify-subscription-error;
    description
      "The publisher has insufficient resources to support the
       requested subscription.";
  }
  
  identity no-such-subscription {
    base modify-subscription-error;
    base delete-subscription-error;
    base subscription-terminated-reason;
    description
     "Referenced subscription doesn't exist. This may be as a result of 
      a non-existent subscription ID, an ID which belongs to another 
      subscriber, or an ID for configured subscription.";
  }

  identity replay-unsupported {
    base establish-subscription-error;
    description
     "Replay cannot be performed for this subscription. This means the
      publisher will not provide the requested historic information from
      the stream via replay to this receiver.";
  }
  
  identity stream-unavailable {
    base subscription-terminated-reason;
    description
     "Not a subscribable stream.  This means the referenced stream is 
      not available for subscription by the receiver.";
  }
  
  identity suspension-timeout {
    base subscription-terminated-reason;
    description
     "Termination of previously suspended subscription. The publisher 
      has eliminated the subscription as it exceeded a time limit for
      suspension.";
  }
  
  identity unsupportable-volume {
    base subscription-suspended-reason;
    description
      "The publisher cannot support the volume of information intended
      to be sent for an existing subscription.";
  }

  /* Identities for encodings */
  identity encodings {
    description
      "Base identity to represent data encodings";
  }
  
  identity encode-xml {
    base encodings;
    if-feature "encode-xml";
    description
      "Encode data using XML";
  }
  
  identity encode-json {
    base encodings;
    if-feature "encode-json";
    description
      "Encode data using JSON";
  }

  /* Identities for transports */
  identity transport {
    description
      "An identity that represents a the underlying mechanism for 
      passing notification messages.";
  }
  
  identity netconf {
    base transport;
    description
      "Netconf is used a transport for notification messages and state
       change notifications.";
    reference "draft-ietf-netconf-netconf-event-notifications";
  }
  
  identity http2 {
    base transport;
    description
      "HTTP2 is used a transport for notification messages and state
       change notifications.";
    reference "draft-ietf-netconf-restconf-notif-03, Sections 3.1.1" +
      "3.1.3";
  }

  identity http1.1 {
    base transport;
    description
      "HTTP1.1 is used a transport for notification messages and state
       change notifications.";
    reference "draft-ietf-netconf-restconf-notif-03, Section 3.1.2";
  }   
  
  /*
   * TYPEDEFs
   */

  typedef subscription-id {
    type uint32;
    description
      "A type for subscription identifiers.";
  }

  typedef filter-id {
    type string;
    description
      "A type to identify filters which can be associated with a 
       subscription.";
  } 
  
  typedef encoding {
    type identityref {
      base encodings;
    }
    description
      "Specifies a data encoding, e.g. for a data subscription.";
  }    
  
  typedef transport {
    type identityref {
      base transport;
    }
    description
      "Specifies protocol used to send notification messages to a
       receiver.";
  }

  typedef stream-ref {
    type leafref {
      path "/sn:streams/sn:stream/sn:name";
    }
    description
      "This type is used to reference a system-provided datastream.";
  }

  typedef stream-filter-ref {
    type leafref {
      path "/sn:filters/sn:stream-filter/sn:identifier";
    }
    description
      "This type is used to reference a configured stream filter.";
  }

  /*
   * GROUPINGS
   */
   
  grouping stream-filter-elements {
    description
      "This grouping defines the base for filters applied to event 
       streams.";
    choice filter-spec {
      description
        "The content filter specification for this request.";
      anydata stream-subtree-filter {
        if-feature "subtree";
        description
          "Event stream evaluation criteria encoded in the syntax of a 
          subtree filter as defined in RFC 6241, Section 6. 
          
          The subtree filter is applied to the representation of 
          individual, delineated event records as contained within the 
          event stream.  For example, if the notification message 
          contains an instance of a notification defined in YANG, then 
          the top-level element is the name of the YANG notification.
 
          If the subtree filter returns a non-empty node set, the filter
          matches the event record, and the it is included in the 
          notification message sent to the receivers.";
        reference "RFC 6241, Section 6.";  
      }
      leaf stream-xpath-filter {
        if-feature "xpath";
        type yang:xpath1.0;
        description
          "Event stream evaluation criteria encoded in the syntax of
           an XPath 1.0 expression.

           The XPath expression is evaluated on the representation of
           individual, delineated event records as contained within
           the event stream.  For example, if the notification message
           contains an instance of a notification defined in YANG,
           then the top-level element is the name of the YANG
           notification, and the root node has this top-level element
           as the only child.

           The result of the XPath expression is converted to a
           boolean value using the standard XPath 1.0 rules.  If the
           boolean value is 'true', the filter matches the event
           record, and the it is included in the notification message
           sent to the receivers.

           The expression is evaluated in the following XPath context:

             o  The set of namespace declarations are those in scope on
                the 'xpath-filter' leaf element

             o  The set of variable bindings is empty.

             o  The function library is the core function library, and
                the XPath functions defined in section 10 in RFC 7950.

             o  The context node is the root node.";
        reference
          "http://www.w3.org/TR/1999/REC-xpath-19991116
           RFC 7950, Section 10.";

      }
    }
  } 
  
  grouping update-qos {
    description
      "This grouping describes Quality of Service information
       concerning a subscription.  This information is passed to lower
       layers for transport prioritization and treatment";
    leaf dscp {
      if-feature "qos";
      type inet:dscp;
      default "0";
      description
        "The push update's IP packet transport priority. This is made 
         visible across network hops to receiver. The transport 
         priority is shared for all receivers of a given subscription.";
    }
    leaf weighting {
      if-feature "qos";
      type uint8 {
         range "0 .. 255";
      }
      description
        "Relative weighting for a subscription. Allows an underlying 
         transport layer perform informed load balance allocations 
         between various subscriptions";
      reference 
        "RFC-7540, section 5.3.2";
    }
    leaf dependency {
      if-feature "qos";
      type subscription-id;
      description
        "Provides the Subscription ID of a parent subscription which 
         has absolute priority should that parent have push updates
         ready to egress the publisher. In other words, there should be
         no streaming of objects from the current subscription if   
         the parent has something ready to push.";
      reference 
        "RFC-7540, section 5.3.1";
    }
  }
   
  grouping subscription-policy-modifiable {
    description
      "This grouping describes all objects which may be changed
      in a subscription via an RPC.";  
    choice target {
      mandatory true;
      description
        "Identifies the source of information against which a 
        subscription is being applied, as well as specifics on the 
        subset of information desired from that source.  This choice 
        exists so that additional filter types can be added via 
        augmentation.";
      case stream {
        choice stream-filter {
          description
            "An event stream filter can be applied to a subscription.  
            That filter will come either referenced from a global list,  
            or be provided within the subscription itself.";
          case by-reference {
            description
              "Apply a filter that has been configured separately.";
            leaf stream-filter-ref {
              type stream-filter-ref;
              mandatory true;
              description
                "References an existing stream-filter which is to 
                be applied to stream for the subscription.";
            }
          }
          case within-subscription {
            description
              "Local definition allows a filter to have the same   
              lifecycle as the subscription.";
            uses stream-filter-elements;
          }
        }
      }
    }
    leaf stop-time {
      type yang:date-and-time;
      description
        "Identifies a time after which notification messages for a
        subscription should not be sent.  If stop-time is not present, 
        the notification messages will continue until the subscription 
        is terminated.  If replay-start-time exists, stop-time must be
        for a subsequent time. If replay-start-time doesn't exist, 
        stop-time must be for a future time.";
    }
  }
 
  grouping subscription-policy-dynamic {
    description
      "This grouping describes information concerning a subscription
      which can be passed over the RPCs defined in this model.";
    leaf encoding {
      type encoding;
      mandatory true;
      description
        "The type of encoding for the subscribed data.";
    }    
    uses subscription-policy-modifiable {
      augment target/stream {
        description
          "Adds additional objects which can be modified by RPC.";
        leaf stream {
          type stream-ref {
            require-instance false;
          }
          mandatory true;
          description
            "Indicates the stream of event records to be considered for
            this subscription.";
        }
        leaf replay-start-time {
          if-feature "replay";
          type yang:date-and-time;
          description
            "Used to trigger the replay feature and indicate that the 
            replay should start at the time specified.  If 
            replay-start-time is not present, this is not a replay 
            subscription and event record push should start immediately.  
            It is never valid to specify start times that are later than 
            or equal to the current time.";
        }  
      }
    }
    uses update-qos;    
  }

  grouping subscription-policy {
    description
      "This grouping describes the full set of policy information 
      concerning both dynamic and configured subscriptions, except for 
      configured receivers.";
    leaf protocol {
      if-feature "configured";
      type transport;
      mandatory true;
      description
        "This leaf specifies the transport protocol used to deliver 
        messages destined to all receivers of a subscription.";
    }    
    uses subscription-policy-dynamic; 
  }

  grouping notification-origin-info {
    description
      "Defines the sender source from which notification messages for a 
       configured subscription are sent.";
    choice notification-message-origin {
      description
        "Identifies the egress interface on the Publisher from which
         notification messages are to be sent.";
      case interface-originated {
        description
          "When notification messages to egress a specific, designated
           interface on the Publisher.";
        leaf source-interface {
          type if:interface-ref;
          description
            "References the interface for notification messages.";
        }
      }
      case address-originated {
        description
          "When notification messages are to depart from a publisher
             using specfic originating address and/or routing context
           information.";
        leaf source-vrf {
          if-feature "supports-vrf";
          type leafref {
            path "/ni:network-instances/ni:network-instance/ni:name";
          }
          description
            "VRF from which notification messages should egress a 
            publisher.";
        }
        leaf source-address {
          type inet:ip-address-no-zone;
          description
            "The source address for the notification messages.  If a
            source VRF exists, but this object doesn't, a publisher's
            default address for that VRF must be used.";
        }
      }
    }
  }

  grouping receiver-info {
    description
      "Defines where and how to get notification messages for a
      configured subscriptions to one or more targeted recipient.  This
      includes specifying the destination addressing as well as a 
      transport protocol acceptable to the receiver.";
    container receivers {
      description
        "Set of receivers in a subscription.";
      list receiver {
        key "address port";
        min-elements 1;
        description
          "A single host or multipoint address intended as a target
           for the notification messages of a subscription.";
        leaf address {
          type inet:host;
          description
            "Specifies the address for the traffic to reach a remote 
            host. One of the following must be specified: an ipv4 
            address, an ipv6 address, or a host name.";
        }
        leaf port {
          type inet:port-number;
          description
            "This leaf specifies the port number to use for messages
             destined for a receiver.";
        }
      }
    }
  }

  /*
   * RPCs
   */
   
  rpc establish-subscription {
    description
      "This RPC allows a subscriber to create (and possibly negotiate) 
       a subscription on its own behalf.  If successful, the 
       subscription remains in effect for the duration of the 
       subscriber's association with the publisher, or until the 
       subscription is terminated. In case an error occurs, or the 
       publisher cannot meet the terms of a subscription, and RPC error 
       is returned, the subscription is not created.  In that case, the 
       RPC reply's error-info MAY include suggested parameter settings 
       that would have a higher likelihood of succeeding in a subsequent 
       establish-subscription request.";
    input {
      uses subscription-policy-dynamic {
        refine "encoding" {
          mandatory false;
          description
            "The type of encoding for the subscribed data. If not
            included as part of the RPC, the encoding MUST be set by the 
            publisher to be the encoding used by this RPC.";
        }
      }
    }
    output {
      leaf identifier {
        type subscription-id;
        mandatory true;
        description
          "Indicates that a subscription has successfully been created
          and provides the identifier used by the publisher.";
      }
    }
  }
    

  rc:yang-data establish-subscription-error-stream {
    container establish-subscription-error-stream {
      description
        "If any 'establish-subscription' RPC parameters are 
        unsupportable against the event stream, a subscription is not 
        created and the RPC error response MUST indicate the reason 
        why the subscription failed to be created. This yang-data MAY be 
        inserted as structured data within a subscription's RPC error 
        response to indicate the failure reason.  This yang-data MUST be 
        inserted if hints are to be provided back to the subscriber.";
      leaf reason {
        type identityref {
          base establish-subscription-error;
        }
        description
          "Indicates the reason why the subscription has failed to
          be created to a targeted stream.";
        }
      leaf filter-failure-hint { 
        type string;
          description
            "Information describing where and/or why a provided filter
             was unsupportable for a subscription.";
      }
      leaf replay-start-time-hint {
        type yang:date-and-time;
          description
            "If a replay has been requested, but the requested replay
            time cannot be honored, this may provide a hint at an
            alternate time which may be supportable.";
      }
    }      
  }
  
  rpc modify-subscription {
    description
      "This RPC allows a subscriber to modify a subscription that was
       previously created using establish-subscription.  If successful,
       the changed subscription remains in effect for the duration of 
       the subscriber's association with the publisher, or until the
       subscription is again modified or terminated.  In case of an 
       error or an inability to meet the modified parameters, the 
       subscription is not modified and the original subscription
       parameters remain in effect.  In that case, the rpc error 
       MAY include error-info suggested parameter hints that would have 
       a high likelihood of succeeding in a subsequent 
       modify-subscription request.  A successful modify-subscription
       will return a suspended subscription to an active state.";
    input {
      leaf identifier {
        type subscription-id;
        description
          "Identifier to use for this subscription.";
      }
      uses subscription-policy-modifiable;   
    }
    output {
      leaf ok {
        type empty;
        mandatory true;
        description
          "Indicates a subscription has been modified.";
      }
    }
  }
  
  rc:yang-data modify-subscription-error-stream {
    container modify-subscription-error-stream {
      description
        "This yang-data MAY be provided as part of a subscription's RPC
        error response when there is a failure of a
        'modify-subscription' RPC which has been made against a 
        stream.  This yang-data MUST be used if hints are to be
        provides back to the subscriber.";
      leaf reason {
        type identityref {
          base modify-subscription-error;
        }
        description
          "Information in a modify-subscription RPC error response which 
          indicates the reason why the subscription to an event stream 
          has failed to be modified.";
      }
      leaf filter-failure-hint { 
        type string;
          description
            "Information describing where and/or why a provided filter
             was unsupportable for a subscription.";
      }
    }
  }
  
  rpc delete-subscription {
    description
      "This RPC allows a subscriber to delete a subscription that
       was previously created from by that same subscriber using the 
       establish-subscription RPC.";
    input {
      leaf identifier {
        type subscription-id;
        mandatory true;
        description
          "Identifier of the subscription that is to be deleted.
           Only subscriptions that were created using
           establish-subscription can be deleted via this RPC.";
      }
    }
    output {
      leaf ok {
        type empty;
        mandatory true;
        description
          "Indicates a subscription has been deleted.";
      }
    }
  }
  
  rpc kill-subscription {
    description
      "This RPC allows an operator to delete a dynamic subscription 
      without restrictions on the originating subscriber or underlying 
      transport session.";
    input {
      leaf identifier {
        type subscription-id;
        mandatory true;
        description
          "Identifier of the subscription that is to be deleted. Only
            subscriptions that were created using establish-subscription
           can be deleted via this RPC.";
      }
    }
    output {
      leaf ok {
        type empty;
        mandatory true;
        description
          "Indicates that a subscription has been killed.";
      }
    }
  }
  
  rc:yang-data delete-subscription-error {
    container delete-subscription-error {
      description
        "If a 'delete-subscription' RPC or a 'kill-subscription' RPC 
        fails, the subscription is not deleted and the RPC error 
        response MUST indicate the reason for this failure. This 
        yang-data MAY be inserted as structured data within a 
        subscription's RPC error response to indicate the failure 
        reason.";
      leaf reason {
        type identityref {
          base delete-subscription-error;
        }
        mandatory true;
        description
          "Indicates the reason why the subscription has failed to be 
          deleted.";
      }
    }
  }
  
  /*
   * NOTIFICATIONS
   */

  notification replay-completed {
    sn:subscription-state-notification;
    if-feature "replay";
    description
      "This notification is sent to indicate that all of the replay
        notifications have been sent. It must not be sent for any other
       reason.";
    leaf identifier {
      type subscription-id;
      mandatory true;
      description
        "This references the affected subscription.";
    }
  }
  
  notification subscription-completed {
    sn:subscription-state-notification;
    description
      "This notification is sent to indicate that a subscription has
       finished passing event records.";
    leaf identifier {
      type subscription-id;
      mandatory true;
      description
        "This references the gracefully completed subscription.";
    }
  }

  notification subscription-started {
    sn:subscription-state-notification;
    if-feature "configured";
    description
      "This notification indicates that a subscription has started and
        notifications are beginning to be sent. This notification shall
       only be sent to receivers of a subscription; it does not 
       constitute a general-purpose notification.";
    leaf identifier {
      type subscription-id;
      mandatory true;
      description
        "This references the affected subscription.";
    }
    uses subscription-policy {
      refine "target/stream/replay-start-time" {
         description
           "Indicates the time that a replay using for the streaming of 
           buffered event records.  This will be populated with the most 
           recent of the following: replay-log-creation-time, 
           replay-log-aged-time, replay-start-time, or the most recent 
           publisher boot time.";
      }
      refine "target/stream/stream-filter/within-subscription" {
        description 
          "Filter applied to the subscription.  If the 
          'stream-filter-ref' is populated, the filter within the
          subscription came from the 'filters' container.  Otherwise it 
          is populated in-line as part of the subscription.";
      }
    }
  }
  
  notification subscription-resumed {
    sn:subscription-state-notification;
    description
      "This notification indicates that a subscription that had
       previously been suspended has resumed. Notifications will once
       again be sent.  In addition, a subscription-resumed indicates 
       that no modification of parameters has occurred since the last
       time event records have been sent.";
    leaf identifier {
      type subscription-id;
      mandatory true;
      description
        "This references the affected subscription.";
    }
  }
  
  notification subscription-modified {
    sn:subscription-state-notification;
    description
      "This notification indicates that a subscription has been 
       modified.  Notification messages sent from this point on will 
       conform to the modified terms of the subscription.  For  
       completeness, this state change notification includes both 
       modified and non-modified aspects of a subscription.";
    leaf identifier {
      type subscription-id;
      mandatory true;
      description
        "This references the affected subscription.";
    }
    uses subscription-policy {
      refine "target/stream/stream-filter/within-subscription" {
        description 
          "Filter applied to the subscription.  If the 
          'stream-filter-ref' is populated, the filter within the
          subscription came from the 'filters' container.  Otherwise it 
          is populated in-line as part of the subscription.";
      }
    }
  }
  
  notification subscription-terminated {
    sn:subscription-state-notification;
    description
      "This notification indicates that a subscription has been
       terminated.";
    leaf identifier {
      type subscription-id;
      mandatory true;
      description
        "This references the affected subscription.";
    }
    leaf reason {
      type identityref {
        base subscription-terminated-reason;
      }
      mandatory true;
      description
        "Identifies the condition which resulted in the termination .";
    }
  }

  notification subscription-suspended {
    sn:subscription-state-notification;
    description
      "This notification indicates that a suspension of the
       subscription by the publisher has occurred.  No further
       notifications will be sent until the subscription resumes.
       This notification shall only be sent to receivers of a
       subscription; it does not constitute a general-purpose
       notification.";
    leaf identifier {
      type subscription-id;
      mandatory true;
      description
        "This references the affected subscription.";
    }
    leaf reason {
      type identityref {
        base subscription-suspended-reason;
      }
      mandatory true;
      description
        "Identifies the condition which resulted in the suspension.";
    }
  }

  /*
   * DATA NODES
   */

  container streams {
    config false;
    description
      "This container contains information on the built-in streams 
      provided by the publisher.";
    list stream {
      key "name";
      description
        "Identifies the built-in streams that are supported by the
         publisher.";
      leaf name {
        type string;
        description
          "A handle for a system-provided datastream made up of a 
          sequential set of event records, each of which is 
          characterized by its own domain and semantics.";
      }
      leaf description {
        type string;
        mandatory true;
        description
          "A description of the event stream, including such information 
           as the type of event records that are available within this 
           stream.";
      }
      leaf replay-support {
        if-feature "replay";
        type empty;
        description
          "Indicates that event record replay is available on this 
          stream.";
      }
      leaf replay-log-creation-time {
        if-feature "replay";
        type yang:date-and-time;
        description
          "The timestamp of the creation of the log used to support the 
          replay function on this stream. Note that this might be 
          earlier then the earliest available information contained in   
          the log. This object is updated if the log resets for some   
          reason. This object MUST be present if replay is supported.";
      }
      leaf replay-log-aged-time {
        if-feature "replay";
        type yang:date-and-time;
        description
          "The timestamp of the last event record aged out of the log. 
          This object MUST be present if replay is supported and any 
          event record have been aged out of the log.";
      }
    }
  }
   
  container filters {
    description
      "This container contains a list of configurable filters
       that can be applied to subscriptions.  This facilitates
       the reuse of complex filters once defined.";
    list stream-filter {
      key "identifier";
      description
        "A list of pre-positioned filters that can be applied to
        subscriptions.";
      leaf identifier {
        type filter-id;
        description
          "An identifier to differentiate between filters.";
      }
      uses stream-filter-elements;
    }
  }
  
  container subscriptions {
    description
      "Contains the list of currently active subscriptions, i.e.
       subscriptions that are currently in effect, used for subscription
       management and monitoring purposes. This includes subscriptions
       that have been setup via RPC primitives as well as subscriptions 
       that have been established via configuration.";
    list subscription {
      key "identifier";
      description
        "The identity and specific parameters of a subscription. 
         Subscriptions within this list can be created using a control
         channel or RPC, or be established through configuration.";
      leaf identifier {
        type subscription-id;
        description
          "Identifier of a subscription; unique within a publisher";
      }
      leaf configured-subscription-state {
        if-feature "configured";
        type enumeration {
          enum valid {
            value 1;
            description
              "Connection is active and healthy.";
          }
          enum invalid {
            value 2;
            description
              "The subscription as a whole is unsupportable with its 
              current parameters.";
          }
          enum concluded {
            value 3;
              description
                "A subscription is inactive as it has hit a stop time, 
                but not yet been removed from configuration.";
          }
        }
        config false;
        description
          "The presence of this leaf indicates that the subscription
          originated from configuration, not through a control channel 
          or RPC.  The value indicates the system established status
          of the subscription.";
      }
      leaf purpose {
        if-feature "configured";
        type string;
        description
          "Open text allowing a configuring entity to embed the 
          originator or other specifics of this subscription.";
      }
      uses subscription-policy {
        refine "target/stream/stream" {
          description
            "Indicates the stream of event records to be considered for
            this subscription.   If a stream has been removed, and no 
            longer can be referenced by an active subscription, send a 
            'subscription-terminated' notification with 
            'stream-unavailable' as the reason.  If a configured 
            subscription refers to a non-existent stream, move that
            subscription to the 'invalid' state.";
        }
      }
      uses notification-origin-info {
        if-feature "configured";
      }
      uses receiver-info {
        augment receivers/receiver {
          description
            "include operational data for receivers.";
          leaf pushed-notifications {
            type yang:counter64;
            config false;
            description
              "Operational data which provides the number of update
               notification messages pushed to a receiver.";
            } 
          leaf excluded-notifications {
            type yang:counter64;
            config false;
            description
              "Operational data which provides the number of event
               records from a stream explicitly removed via filtering so
               that they are not sent to a receiver.";
            }
          leaf status {
            type enumeration {
              enum active {
                value 1;
                description
                  "Receiver is currently being sent any applicable 
                  notification messages for the subscription.";
              }
              enum suspended {
                value 2;
                description
                  "Receiver status is suspended, so the publisher 
                  is currently unable to provide notification messages 
                  for the subscription.";
              }
              enum connecting {
                value 3;
                if-feature "configured";
                description
                  "A subscription has been configured, but a 
                  subscription-started state change notification needs  
                  to be successfully received before notification 
                  messages are sent.";
              }
              enum timeout {
                value 4;
                if-feature "configured";
                description
                  "A subscription has failed in sending a subscription
                  started state change to the receiver.  
                  Additional attempts at connection attempts are not 
                  currently being made.";
              }
            }
            config false;
            mandatory true;
            description
              "Specifies the status of a subscription from the 
              perspective of a particular receiver.  With this info it 
              is possible to determine whether a subscriber is currently
              generating notification messages intended for that 
              receiver.";
          }
          action reset {
            description
              "Allows the reset of this configured subscription receiver
              to the 'connecting' state. This enables the
              connection process to be reinitiated.";
            output {
              leaf time {
                type yang:date-and-time;
                mandatory true;
                description
                  "Time a publisher returned the receiver to a
                  connecting status.";
              }
            }
          }          
        }
      }
    }
  }
}
<CODE ENDS> 
          ]]></artwork>
        </figure>                
      </section>
        
               
      <section title="Considerations">
    
        <section title="Implementation Considerations">
          <t>For a deployment including both configured and dynamic subscriptions, split subscription identifiers into static and dynamic halves.  That way it is unlikely there will be collisions if the configured subscriptions attempt to set a subscription-id which might have already been dynamically allocated. The lower half the "identifier" object in the subscriptions container SHOULD be used when the "identifier" is selected and assigned by an external entity (such as with a configured subscription). And the upper half SHOULD be used for subscription identifiers dynamically chosen and assigned by the publisher</t>
        
          <t>Neither state change notification nor subscribed event records within notification messages may be sent before the transport layer, including any required capabilities exchange, has been established.</t>
        
          <t>An implementation may choose to transition between active and suspended subscription states more frequently than required by this specification.  However if a subscription is unable to marshal all intended updates into a transmittable message in multiple successive intervals, the subscription SHOULD be suspended with the reason "unsupportable-volume".</t>
        
          <t>For configured subscriptions, operations are against the set of receivers using the subscription identifier as a handle for that set. But for streaming up dates, state change notifications are local to a receiver. In this specification it is the case that receivers get no information from the publisher about the existence of other receivers.   But if an operator wants to let the receivers correlate results, it is useful to use the subscription identifier handle across the receivers to allow that correlation.</t>     
        </section>
        
         <section title="IANA Considerations">
   <t>
   This document registers the following namespace URI in the "IETF XML
   Registry" <xref target="RFC3688"/>:
   </t>

   <t>
   URI:  urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications
   <vspace/>
   Registrant Contact: The IESG.
   <vspace/>
   XML: N/A; the requested URI is an XML namespace.
   </t>
   
   <t>
   This document registers the following YANG module in the "YANG
   Module Names" registry <xref target="RFC6020"/>:
   </t>
   <t>
   Name:      ietf-subscribed-notifications
   <vspace/>
   Namespace: urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications
   <vspace/>
   Prefix:    sn
   <vspace/>
   Reference: draft-ietf-netconf-ietf-subscribed-notifications-08.txt 
              (RFC form) 
   </t>
   </section>
        
        <section title="Security Considerations">
        
          <t>For dynamic subscriptions the publisher MUST authenticate and authorize all RPC requests.</t>
        
          <t>Subscriptions could overload a publisher's CPU. For this reason, the publisher MUST have the ability to decline a dynamic subscription request, and provide the appropriate RPC error response to a subscriber should the proposed subscription overly deplete the publisher's resources.</t>

          <t>A publisher needs to be able to suspend an existing dynamic or configured subscription based on capacity constraints. When this occurs, the subscription status MUST be updated accordingly and the receivers notified with subscription state notifications.</t>
        
          <t>If a malicious or buggy subscriber sends an unexpectedly large number of RPCs, the result might be an excessive use of system resources. In such a situation, subscription interactions MAY be terminated by terminating the transport session.</t>
        
          <t>For both configured and dynamic subscriptions the publisher MUST authenticate and authorize a receiver via some transport level mechanism before sending any updates.</t>
        
          <t>A secure transport is highly recommended and the publisher MUST ensure that the receiver has sufficient authorization to perform the function they are requesting against the specific subset of content involved.</t>
        
          <t>A publisher MUST NOT include any content in a notification  message for which the receiver has not been authorized.</t>
        
          <t>With configured subscriptions, one or more publishers could be used to overwhelm a receiver.  No notification messages SHOULD be sent to any receiver which doesn't even support subscriptions.  Receivers that do not want notification messages need only terminate or refuse any transport sessions from the publisher.</t>

          <t>The NETCONF Authorization Control Model <xref target="RFC6536bis"/> SHOULD be used to control and restrict authorization of subscription configuration. This control models permits specifying per-receiver permissions to receive event records from specific streams.</t>
            
          <t>Where NACM is available, the NACM "very-secure" tag MUST be placed on the "kill-subscription" RPC so that only administrators have access to use this.</t>
        
          <t>One subscription id can be used for two or more receivers of the same configured subscription.  But due to the possibility of different access control permissions per receiver, it SHOULD NOT be assumed that each receiver is getting identical updates.</t>  

        </section>    
        
      </section>
        
      <section title="Acknowledgments">
        <t>For their valuable comments, discussions, and feedback, we wish to acknowledge Andy Bierman, Tim Jenkins, Martin Bjorklund, Kent Watsen, Balazs Lengyel, Robert Wilton, Sharon Chisholm, Hector Trevino, Susan Hares, Michael Scharf, and Guangying Zheng.  
        </t>
      </section>
    </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.3688"?>
      <?rfc include="reference.RFC.5277"?>
      <?rfc include="reference.RFC.6020"?>
      <?rfc include="reference.RFC.7540"?>
      <?rfc include="reference.RFC.7950"?>
      
      <reference anchor="XPATH"
                 target="http://www.w3.org/TR/1999/REC-xpath-19991116">
        <front>
          <title>XML Path Language (XPath) Version 1.0</title>
          <author fullname="J Clark" initials="J" surname="Clark"></author>
          <author fullname="S DeRose" initials="S" surname="DeRose"></author>
          <date month="November" year="1999"/>
        </front>
      </reference>

      <reference anchor="RFC6536bis">
        <front>
          <title>Network Configuration Protocol (NETCONF) Access Control Model</title>
            <author fullname="Andy Bierman" initials="A" surname="Bierman">
            </author>
            <author fullname="Martin Bjorklund" initials="M" surname="Bjorklund">
          </author>
          <date month="September" year="2017"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-netconf-rfc6536bis-01"/>
        <format target="https://tools.ietf.org/html/draft-ietf-netconf-rfc6536bis-05"
                type="TXT"/>
      </reference>      
    
      <reference anchor="I-D.draft-ietf-rtgwg-ni-model">
        <front>
          <title>YANG Network Instances</title>
            <author fullname="Lou Berger" initials="L" surname="Berger"> </author>
            <author fullname="Christan Hopps" initials="C" surname="Hopps"> </author>
            <author fullname="Acee Lindem" initials="A" surname="Lindem"> </author>
          <date month="July" year="2017"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-rtgwg-ni-model-03"/>
        <format target="https://tools.ietf.org/html/draft-ietf-rtgwg-ni-model-03"
                type="TXT"/>
      </reference> 
    
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.8040"?>
      <?rfc include="reference.RFC.7923"?>
      <?rfc include="reference.RFC.6241"?>
      <reference anchor="I-D.ietf-netconf-yang-push"
                 target="https://datatracker.ietf.org/doc/draft-ietf-netconf-yang-push/">
        <front>
          <title>YANG Datastore Subscription</title>
          <author fullname="A Clemm" initials="Alexander" surname="Clemm"></author>
          <author fullname="E Voit" initials="Eric" surname="Voit"></author>
          <author fullname="A Gonzalez Prieto" initials="Alberto" surname="Gonzalez Prieto"></author>
          <author fullname="Ambika Prasad Tripathy" initials="A" surname="Tripathy"></author>
          <author fullname="Einar Nilsen-Nygaard" initials="E" surname="Nilsen-Nygaard"></author>
          <author fullname="Andy Bierman" initials="A" surname="Bierman"></author>
          <author fullname="B Lengyel" initials="B" surname="Lengyel"></author>
          <date month="October" year="2017"/>
        </front>
      </reference>
      
      <reference anchor="I-D.draft-ietf-netconf-netconf-event-notifications"
                 target="https://datatracker.ietf.org/doc/draft-ietf-netconf-netconf-event-notifications/">
        <front>
          <title>NETCONF support for event notifications</title>
          <author fullname="A Clemm" initials="Alexander" surname="Clemm"></author>
          <author fullname="E Voit" initials="Eric" surname="Voit"></author>
          <author fullname="A Gonzalez Prieto" initials="Alberto" surname="Gonzalez Prieto"></author>
          <author fullname="Einar Nilsen-Nygaard" initials="E" surname="Nilsen-Nygaard"></author>
          <author fullname="Ambika Prasad Tripathy" initials="A" surname="Tripathy"></author>
          <author fullname="Sharon Chisholm" initials="S" surname="Chisholm"></author>
          <author fullname="Hector Trevino" initials="H" surname="Trevino"></author>
          <date month="October" year="2016"/>
        </front>
      </reference>
      
      <reference anchor="I-D.draft-ietf-netconf-restconf-notif"
                 target="https://datatracker.ietf.org/doc/draft-ietf-netconf-restconf-notif/">
        <front>
          <title>Restconf and HTTP transport for event notifications</title>

          <author fullname="E Voit" initials="Eric" surname="Voit"></author>
          <author fullname="A Clemm" initials="Alexander" surname="Clemm"></author>
          <author fullname="Ambika Prasad Tripathy" initials="A" surname="Tripathy"></author>
          <author fullname="Einar Nilsen-Nygaard" initials="E" surname="Nilsen-Nygaard"></author> 
          <author fullname="A Gonzalez Prieto" initials="Alberto" surname="Gonzalez Prieto"></author>
          <date day="26" month="August" year="2016"/>
        </front>
      </reference>
      
      <reference anchor="I.D.draft-ietf-netconf-notification-messages"
                 target="https://datatracker.ietf.org/doc/draft-ietf-netconf-notification-messages">
        <front>
          <title>YANG Notification Headers and Bundles</title>

          <author fullname="E Voit" initials="Eric" surname="Voit"></author>
          <author fullname="A Clemm" initials="Alexander" surname="Clemm"></author>
          <author fullname="A Bierman" initials="A" surname="Bierman"></author>
          <author fullname="T Jenkins" initials="T" surname="Jenkins"></author> 
          <date month="September" year="2017"/>
        </front>
      </reference>
    </references>
    
    <section title="Appendix A: Subscription Errors" anchor="appendix_a">
      <section title="RPC Failures" anchor="appendix_a1">
    
        <t>Whenever an RPC is unsuccessful, the publisher returns relevant error codes as part of the RPC error response. RPC error codes returned include both existing transport layer RPC error codes, such as those seen with NETCONF in <xref target="RFC6241"/> Appendix A, as well as subscription specific errors such as those defined within this document's YANG model.  As a result of this mixture, how subscription errors are encoded within an RPC error response is transport dependent. </t>
    
        <t>There are elements of the RPC error mechanism which are transport independent. Specifically, references to specific identities within the YANG model MUST be returned as part of the error responses resulting from failed attempts at event stream subscription. Following are valid errors per RPC:</t>
        <figure>
          <artwork align="left"><![CDATA[    
establish-subscription         modify-subscription 
----------------------         -------------------  
 dscp-unavailable               filter-unsupported      
 filter-unsupported             insufficient-resources
 history-unavailable            no-such-subscription
 insufficient-resources
 replay-unsupported
 
delete-subscription            kill-subscription
----------------------         ----------------------
 no-such-subscription            no-such-subscription
              ]]></artwork>
        </figure>
        
        <t>There is one final set of transport independent RPC error elements included in the YANG model.  These are the following three yang-data structures for failed event stream subscriptions:
        
		<list style="numbers">  
          <t>yang-data establish-subscription-error-stream: This MUST be returned if an RPC error reason has not been placed elsewhere within the transport portion of a failed "establish-subscription" RPC response.   This MUST be sent if hints on how to overcome the RPC error are included.</t>

          <t>yang-data modify-subscription-error-stream: This MUST be returned if an RPC error reason has not been placed elsewhere within the transport portion of a failed "modify-subscription" RPC response. This MUST be sent if hints on how to overcome the RPC error are included.</t>

          <t>yang-data delete-subscription-error: This MUST be returned if an RPC error reason has not been placed elsewhere within the transport portion of a failed "delete-subscription" or "kill-subscription" RPC response.</t>  
        </list></t>        
      </section>
      <section title="Notifications of Failure" anchor="appendix_a2">
        
        <t>A subscription may be unexpectedly terminated or suspended independent of any RPC or configuration operation.  In such cases, indications of such a failure MUST be provided.  To accomplish this, the following types of error identities may be returned within the corresponding subscription state change notification:</t>
        
        <figure>
          <artwork align="left"><![CDATA[            
subscription-terminated        subscription-suspended
-----------------------        ---------------------- 
 filter-unavailable             unsupportable-volume
 no-such-subscription
 stream-unavailable
 suspension-timeout
              ]]></artwork>
        </figure> 
      </section>
    </section>
    
    
    <section title="Changes between revisions">
      <t>(To be removed by RFC editor prior to publication)</t>

          <t>v07 - v08 
        <list style="symbols">
		  <t>NMDA model supported.  Non NMDA version at https://github.com/netconf-wg/rfc5277bis/blob/master/ietf-subscribed-notifications-non-nmda%402018-01-24.yang</t>
          <t>Split YANG trees to separate document subsections.</t>
          <t>Clarified configured state machine based on Balazs comments, and moved it into the configured subscription subsections.</t>
          <t>Normative reference to Network Instance model for VRF</t>
          <t>One transport protocol for all receivers of configured subscriptions.</t>
          <t>QoS section moved in from yang-push</t>
          <t>Error mechanism revamped to match to embedded implementations.</t>
		  <t>Added error code Appendix A</t>
        </list>
        </t>
      
          <t>v06 - v07 
        <list style="symbols">
          <t>Clarification on state machine for configured subscriptions.</t>
        </list>
        </t>
      
        <t>v05 - v06 
        <list style="symbols">
          <t>Made changes proposed by Martin, Kent, and others on the list.  Most significant of these are Stream returned to string (with the SYSLOG identity removed), intro section on 5277 relationship, an identity set moved to an enumeration, clean up of definitions/terminology, state machine proposed for configured subscriptions with a clean-up of subscription state options.</t>
          <t>JSON and XML become features.  Also Xpath and subtree filtering become features</t>
          <t>Terminology updates with event records, and refinement of filters to just stream filters.</t>
          <t>Encoding refined in establish-subscription so it takes the RPC's encoding as the default.</t>
          <t>Namespaces in examples fixed.</t>
        </list>
        </t>
      
      <t>v04 - v05 
        <list style="symbols">
          <t>Returned to the explicit filter subtyping of v00</t>
          <t>stream object changed to 'name' from 'stream'</t>
          <t>Cleaned up examples</t>
          <t>Clarified that JSON support needs notification-messages draft.</t>
        </list>
        </t>
      
      <t>v03 - v04</t>
        <t><list style="symbols">
            <t>Moved back to the use of RFC5277 one-way notifications and encodings.</t>
         </list>
      </t>
      
      <t>v03 - v04</t>
      <t><list style="symbols">
            <t>Replay updated</t>
         </list>
      </t>
      
      <t>v02 - v03</t>
      <t><list style="symbols">
            <t>RPCs and Notification support is identified by the Notification 2.0 capability.</t>
            <t>Updates to filtering identities and text</t>
            <t>New error type for unsupportable volume of updates</t>
            <t>Text tweaks.</t>
         </list>
      </t>
     
      <t>v01 - v02</t>
      <t><list style="symbols">
            <t>Subscription status moved under receiver.</t>
         </list>
      </t>
      
      <t>v00 - v01</t>
      <t><list style="symbols">
            <t>Security considerations updated</t>
            <t>Intro rewrite, as well as scattered text changes</t>
            <t>Added Appendix A, to help match this to related drafts in progress</t>
            <t>Updated filtering definitions, and filter types in yang file, and moved to identities for filter types</t>
            <t>Added Syslog as a stream</t>
            <t>HTTP2 moved in from YANG-Push as a transport option</t>
            <t>Replay made an optional feature for events.  Won't apply to datastores</t>
            <t>Enabled notification timestamp to have different formats.</t>
            <t>Two error codes added.</t>
        </list>
      </t>

      <t>v01 5277bis - v00 subscribed notifications</t>
      <t><list style="symbols">
            <t>Kill subscription RPC added.</t>
            <t>Renamed from 5277bis to Subscribed Notifications.</t>
            <t>Changed the notification capabilities version from 1.1 to 2.0.</t>
            <t>Extracted create-subscription and other elements of RFC5277.</t>
            <t>Error conditions added, and made specific in return codes.</t>
            <t>Simplified yang model structure for removal of 'basic' grouping.</t>
            <t>Added a grouping for items which cannot be statically configured.</t>
            <t>Operational counters per receiver.</t>
            <t>Subscription-id and filter-id renamed to identifier</t>
            <t>Section for replay added. Replay now cannot be configured.</t>
            <t>Control plane notification renamed to subscription state notification</t>
            <t>Source address: Source-vrf changed to string, default address option added</t>
            <t>In yang model: 'info' changed to 'policy'</t>
            <t>Scattered text clarifications</t>
        </list>
      </t>

      <t>v00 - v01 of 5277bis</t>
      <t><list style="symbols">
            <t>YANG Model changes.  New groupings for subscription info to allow restriction of what is changeable via RPC.   Removed notifications for adding and removing receivers of configured subscriptions.</t>
            <t>Expanded/renamed definitions from event server to publisher, and client to subscriber as applicable.  Updated the definitions to include and expand on RFC 5277.</t>
            <t>Removal of redundancy with other drafts</t>
            <t>Many other clean-ups of wording and terminology</t>
        </list>
      </t>
      
    </section>
  </back>
</rfc>